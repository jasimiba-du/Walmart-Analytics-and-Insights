# -*- coding: utf-8 -*-
"""Timeseries_Forcasting_Arima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kEgfJ3rp7d4J5VdtbWpNqINPMMc2DnCJ
"""

import pandas as pd
import numpy as np
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller, acf, pacf
from statsmodels.stats.diagnostic import acorr_ljungbox
import seaborn as sns
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('/content/cleaned_data.csv')
df.dtypes

df['date'] = pd.to_datetime(df['date'], errors='coerce')  # Coerce errors to NaT if there are any invalid dates
df = df.dropna(subset=['date'])  # Drop rows where 'date' is NaT after conversion
df.set_index('date', inplace=True)

"""**Resample Data to Monthly Frequency**

"""

# Resample the data to monthly frequency (summing total_price for each month)
monthly_data = df['total_price'].resample('ME').sum()

# Check if the data has any missing values after resampling
if monthly_data.isnull().sum() > 0:
    print("There are missing values in the resampled data. Filling with forward fill method.")
    monthly_data.fillna(method='ffill', inplace=True)

print(monthly_data.shape)

print(monthly_data.index.min())  # First month
print(monthly_data.index.max())  # Last month

# Check for stationarity using Augmented Dickey-Fuller test
result = adfuller(monthly_data)
print(f"ADF Statistic: {result[0]}")
print(f"p-value: {result[1]}")

plt.figure(figsize=(12, 6))
plt.plot(monthly_data, label='Monthly Total Price')
plt.title('Monthly Total Price')
plt.legend()
plt.show()

""" Custom Diagnostics Function


"""

def custom_diagnostics(residuals):
    """Custom diagnostics for small sample sizes"""
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))

    # Residuals over time
    axes[0,0].plot(residuals)
    axes[0,0].set_title('Residuals over Time')
    axes[0,0].axhline(y=0, color='r', linestyle='--')

    # Histogram of residuals
    sns.histplot(residuals, kde=True, ax=axes[0,1])
    axes[0,1].set_title('Residuals Distribution')

    # ACF plot
    acf_values = acf(residuals, nlags=min(20, len(residuals)//2))
    axes[1,0].plot(range(len(acf_values)), acf_values)
    axes[1,0].axhline(y=0, color='r', linestyle='--')
    axes[1,0].axhline(y=1.96/np.sqrt(len(residuals)), linestyle='--', color='gray')
    axes[1,0].axhline(y=-1.96/np.sqrt(len(residuals)), linestyle='--', color='gray')
    axes[1,0].set_title('ACF of Residuals')

    # Q-Q plot
    stats.probplot(residuals, dist="norm", plot=axes[1,1])
    axes[1,1].set_title('Q-Q Plot')

    plt.tight_layout()
    plt.show()

    # Statistical tests
    print("\nDiagnostic Tests:")
    # Shapiro-Wilk test for normality
    _, p_value = stats.shapiro(residuals)
    print(f"Shapiro-Wilk test p-value: {p_value:.4f}")

    # Ljung-Box test using statsmodels
    lb_test = acorr_ljungbox(residuals, lags=[10], return_df=True)
    print(f"Ljung-Box test p-value: {lb_test['lb_pvalue'].values[0]:.4f}")

    # Additional metrics
    print(f"\nResiduals Statistics:")
    print(f"Mean of residuals: {np.mean(residuals):.4f}")
    print(f"Std of residuals: {np.std(residuals):.4f}")
    print(f"Skewness: {stats.skew(residuals):.4f}")
    print(f"Kurtosis: {stats.kurtosis(residuals):.4f}")

def train_and_evaluate_sarima(data, test_size=0.2):
    # Split data
    train_size = int(len(data) * (1 - test_size))
    train = data[:train_size]
    test = data[train_size:]

    # Seasonal decomposition
    decomposition = seasonal_decompose(data, period=12)

    # Plot decomposition
    fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(12, 10))
    decomposition.observed.plot(ax=ax1)
    ax1.set_title('Original')
    decomposition.trend.plot(ax=ax2)
    ax2.set_title('Trend')
    decomposition.seasonal.plot(ax=ax3)
    ax3.set_title('Seasonal')
    decomposition.resid.plot(ax=ax4)
    ax4.set_title('Residual')
    plt.tight_layout()
    plt.show()

    # Check stationarity
    result = adfuller(data)
    print('Stationarity Test:')
    print('ADF Statistic:', result[0])
    print('p-value:', result[1])
    print('Critical values:')
    for key, value in result[4].items():
        print(f'\t{key}: {value}')

    # Define model parameters
    order = (2, 1, 1)  # (p, d, q)
    seasonal_order = (0, 1, 1, 12)  # (P, D, Q, s)

    # Fit model
    model = SARIMAX(train,
                    order=order,
                    seasonal_order=seasonal_order,
                    enforce_stationarity=False,
                    enforce_invertibility=False)

    results = model.fit(disp=False)

    # Make predictions
    predictions = results.get_forecast(steps=len(test))
    pred_mean = predictions.predicted_mean
    pred_ci = predictions.conf_int()

    # Calculate metrics
    mae = mean_absolute_error(test, pred_mean)
    rmse = np.sqrt(mean_squared_error(test, pred_mean))
    mape = np.mean(np.abs((test - pred_mean) / test)) * 100

    # Plot results
    plt.figure(figsize=(12, 6))
    plt.plot(train.index, train, label='Training Data')
    plt.plot(test.index, test, label='Actual Test Data')
    plt.plot(test.index, pred_mean, label='Predictions', color='red')
    plt.fill_between(test.index,
                    pred_ci.iloc[:, 0],
                    pred_ci.iloc[:, 1],
                    color='red', alpha=0.1)
    plt.title('SARIMA Time Series Forecast')
    plt.legend()
    plt.grid(True)
    plt.show()

    print(f"\nModel Parameters:")
    print(f"SARIMA{order}x{seasonal_order}")
    print(f"\nModel Performance Metrics:")
    print(f"MAE: {mae:.2f}")
    print(f"RMSE: {rmse:.2f}")
    print(f"MAPE: {mape:.2f}%")

    # Custom diagnostics
    residuals = results.resid
    custom_diagnostics(residuals)

    return results, pred_mean, (mae, rmse, mape)

# Run the analysis
results, predictions, metrics = train_and_evaluate_sarima(monthly_data)

# Generate future forecasts
future_steps = 12
future_forecast = results.get_forecast(steps=future_steps)
future_mean = future_forecast.predicted_mean
future_ci = future_forecast.conf_int()

# Plot future forecasts
plt.figure(figsize=(12, 6))
plt.plot(monthly_data.index, monthly_data, label='Historical Data')
plt.plot(future_mean.index, future_mean, label='Future Forecast', color='red')
plt.fill_between(future_mean.index,
                future_ci.iloc[:, 0],
                future_ci.iloc[:, 1],
                color='red', alpha=0.1)
plt.title('SARIMA Future Forecast')
plt.legend()
plt.grid(True)
plt.show()

# Print forecast values with confidence intervals
print("\nForecast for next 12 months:")
for date, value, ci_lower, ci_upper in zip(future_mean.index,
                                          future_mean.values,
                                          future_ci.iloc[:, 0],
                                          future_ci.iloc[:, 1]):
    print(f"{date.strftime('%Y-%m')}: {value:.2f} [{ci_lower:.2f}, {ci_upper:.2f}]")

"""**Rolling Average**"""

# Cyclical Analysis using 12-month rolling average
rolling_avg = monthly_data.rolling(window=12).mean()  # 12-month rolling average

plt.figure(figsize=(10, 6))
plt.plot(monthly_data, label='Original Data', color='blue')
plt.plot(rolling_avg, label='12-Month Rolling Average', color='orange')
plt.title('Cyclical Trend Analysis')
plt.legend()
plt.show()

import joblib

# Save the model
joblib.dump(results, 'sarima_model.pkl')